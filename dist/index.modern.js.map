{"version":3,"file":"index.modern.js","sources":["../key.js","../crypt.js","../seed.js","../state.js","../wallet/bitcore-message.js","../wallet/index.js","../index.js"],"sourcesContent":["class Key {\n  constructor(config) {\n    const dbpath = config.db;\n    this.db = new config.Datastore({\n      filename: dbpath + \"/keys.db\",\n      autoload: true,\n    });\n    this.wallet = config.wallet;\n    this.config = config;\n  }\n  setSeed(s) {\n    this.seed = s;\n  }\n  getSeed() {\n    return this.seed;\n  }\n  sign(o) {\n    return this.wallet.sign(o.message, o.key, o.encoding);\n  }\n  encrypt(o) {\n    return this.wallet.encrypt(o.message, o.key);\n  }\n  async findOrCreate(o) {\n    let key = await this.findOne(o);\n    // create a key if it doesn't exist\n    if (!key) {\n      let count = await this.count({});\n      if (this.seed) {\n        key = await this.wallet.create(this.seed, count, o);\n        key = await this.insert(key);\n      } else {\n        console.log(\"Please go to http://localhost:21000 and create a wallet\");\n        return null;\n      }\n    }\n    return key;\n  }\n  findOne(o) {\n    return new Promise((resolve, reject) => {\n      this.db.findOne(o, (err, key) => {\n        if (key) {\n          resolve(this.transform(key));\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  }\n  find(o) {\n    return new Promise((resolve, reject) => {\n      this.db.find(o, (err, keys) => {\n        resolve(\n          keys.map((k) => {\n            return this.transform(k);\n          })\n        );\n      });\n    });\n  }\n  count(o) {\n    return new Promise((resolve, reject) => {\n      this.db.count(o, (err, count) => {\n        resolve(count);\n      });\n    });\n  }\n  insert(key) {\n    return new Promise((resolve, reject) => {\n      this.db.insert(key, (err, doc) => {\n        resolve(this.transform(key));\n      });\n    });\n  }\n  transform(key) {\n    let derived = this.wallet.derive(this.seed, key.path);\n    key.priv = derived.privateKey.toString();\n    key.pub = derived.publicKey.toString();\n    key.address = derived.publicKey.toAddress().toString();\n    return key;\n  }\n  all() {\n    return new Promise((resolve, reject) => {\n      this.db.find({}, (err, keys) => {\n        resolve(\n          keys.map((k) => {\n            return this.transform(k);\n          })\n        );\n      });\n    });\n  }\n}\nexport default Key;\n","import crypto from \"crypto\";\n\nconst algorithm = \"aes-256-cbc\";\n\nexport function encrypt(text, keystr, keyBuffer) {\n  const iv = crypto.randomBytes(16);\n  if (!keyBuffer)\n    keyBuffer = crypto.createHash(\"sha256\").update(keystr).digest();\n  let cipher = crypto.createCipheriv(\"aes-256-cbc\", keyBuffer, iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return { iv: iv.toString(\"hex\"), encryptedData: encrypted.toString(\"hex\") };\n}\n\nexport function decrypt(text, keystr, keyBuffer) {\n  const iv = Buffer.from(text.iv, \"hex\");\n  if (!keyBuffer)\n    keyBuffer = crypto.createHash(\"sha256\").update(keystr).digest();\n  let encryptedText = Buffer.from(text.encryptedData, \"hex\");\n  let decipher = crypto.createDecipheriv(\"aes-256-cbc\", keyBuffer, iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n","import { decrypt, encrypt } from \"./crypt.js\";\n\nclass Seed {\n  constructor(config) {\n    const dbpath = config.db;\n    this.db = new config.Datastore({\n      filename: dbpath + \"/seed.db\",\n      autoload: true,\n    });\n    this.wallet = config.wallet;\n  }\n  get(password) {\n    return new Promise((resolve, reject) => {\n      this.db.findOne({}, (err, r) => {\n        if (r) {\n          try {\n            let decrypted = decrypt(r.hex, password);\n            let s = this.wallet.seed(decrypted);\n            resolve(s);\n          } catch (e) {\n            resolve(null);\n          }\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  }\n  importKey(hex, password) {\n    return new Promise((resolve, reject) => {\n      try {\n        let s = this.wallet.seed(hex);\n        this.db.insert(\n          {\n            hex: encrypt(s.hex, password),\n          },\n          (err, res) => {\n            resolve(s);\n          }\n        );\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  async exportKey(password) {\n    let s = await this.get(password);\n    return s.hex;\n  }\n  count() {\n    return new Promise((resolve, reject) => {\n      this.db.count({}, (err, count) => {\n        resolve(count);\n      });\n    });\n  }\n  create(password) {\n    return new Promise((resolve, reject) => {\n      let s = this.wallet.seed();\n      this.db.insert(\n        {\n          hex: encrypt(s.hex, password),\n        },\n        (err, res) => {\n          resolve(s);\n        }\n      );\n    });\n  }\n}\nexport default Seed;\n","class State {\n  constructor(config) {\n    const dbpath = config.db;\n    this.db = new config.Datastore({\n      filename: dbpath + \"/state.db\",\n      autoload: true,\n    });\n  }\n  setState(s) {\n    this.state = s;\n  }\n  getState() {\n    return this.state;\n  }\n  async findOrCreate(o) {\n    let state = await this.findOne({ host: o.host });\n    // create a state if it doesn't exist\n    if (!state) {\n      state = await this.insert(o);\n    }\n    return state;\n  }\n  findOne(o) {\n    return new Promise((resolve, reject) => {\n      this.db.findOne(o, (err, state) => {\n        if (state) {\n          delete state._id;\n          resolve(state);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  }\n  find(o) {\n    return new Promise((resolve, reject) => {\n      this.db.find(o, (err, states) => {\n        resolve(states);\n      });\n    });\n  }\n  delete(o) {\n    return new Promise((resolve, reject) => {\n      this.db.remove(o, (err, states) => {\n        resolve(states);\n      });\n    });\n  }\n  count(o) {\n    return new Promise((resolve, reject) => {\n      this.db.count(o, (err, count) => {\n        resolve(count);\n      });\n    });\n  }\n  insert(state) {\n    return new Promise((resolve, reject) => {\n      this.db.insert(state, (err, doc) => {\n        this.setState(state);\n        resolve(state);\n      });\n    });\n  }\n  update(state) {\n    return new Promise((resolve, reject) => {\n      this.db.update(\n        { host: state.host },\n        { $set: state },\n        {\n          upsert: true,\n          returnUpdatedDocs: true,\n        },\n        (err, numReplaced, doc) => {\n          console.log(\"UPDATED\", { err, accessToken: doc.accessToken });\n          this.setState(doc);\n          resolve(doc);\n        }\n      );\n    });\n  }\n  all() {\n    return new Promise((resolve, reject) => {\n      this.db.find({}, (err, states) => {\n        resolve(states);\n      });\n    });\n  }\n}\nexport default State;\n","\"use strict\";\n\nimport bitcore from \"bitcore-lib\";\nvar _ = bitcore.deps._;\nvar PrivateKey = bitcore.PrivateKey;\nvar PublicKey = bitcore.PublicKey;\nvar Address = bitcore.Address;\nvar BufferWriter = bitcore.encoding.BufferWriter;\nvar ECDSA = bitcore.crypto.ECDSA;\nvar Signature = bitcore.crypto.Signature;\nvar sha256sha256 = bitcore.crypto.Hash.sha256sha256;\nvar JSUtil = bitcore.util.js;\nvar $ = bitcore.util.preconditions;\n\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @param {String=} encoding - The message encoding (either 'utf8', 'base64', or 'hex')\n * @returns {Message}\n */\nvar Message = function Message(message, encoding = \"utf8\") {\n  if (!(this instanceof Message)) {\n    return new Message(message, encoding);\n  }\n  $.checkArgument(\n    _.isString(message),\n    \"First argument should be a string. You can specify the encoding as the second parameter\"\n  );\n  const validEncodings = [\n    \"ascii\",\n    \"utf8\",\n    \"utf16le\",\n    \"ucs2\",\n    \"base64\",\n    \"latin1\",\n    \"binary\",\n    \"hex\",\n  ];\n\n  $.checkArgument(\n    validEncodings.includes(encoding),\n    \"Second argument should be a valid BufferEncoding: 'utf8', 'hex', or 'base64', etc\"\n  );\n\n  this.message = message;\n  this.encoding = encoding;\n\n  return this;\n};\n\nMessage.MAGIC_BYTES = Buffer.from(\"Bitcoin Signed Message:\\n\");\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message, this.encoding);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([\n    prefix1,\n    Message.MAGIC_BYTES,\n    prefix2,\n    messageBuffer,\n  ]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(\n    privateKey instanceof PrivateKey,\n    \"First argument should be an instance of PrivateKey\"\n  );\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  let wif = privateKey.toWIF();\n  privateKey = PrivateKey.fromWIF(wif);\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString(\"base64\");\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(\n    publicKey instanceof PublicKey,\n    \"First argument should be an instance of PublicKey\"\n  );\n  $.checkArgument(\n    signature instanceof Signature,\n    \"Second argument should be an instance of Signature\"\n  );\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = \"The signature was invalid\";\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, \"base64\"));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(\n    publicKey,\n    bitcoinAddress.network\n  );\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = \"The signature did not match the message digest\";\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function (str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message,\n    encoding: this.encoding,\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function () {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function () {\n  return \"<Message: \" + this.toString() + \">\";\n};\n\nexport default Message;\n","import bitcore from \"bitcore-lib\";\nimport { encrypt as enc } from \"../crypt.js\";\nimport Message from \"./bitcore-message.js\";\ndelete global._bitcore;\n// console.log(identity.toJSON());\n\nexport const sign = (message, key, encoding) => {\n  const privateKey = bitcore.PrivateKey.fromWIF(key.priv);\n  const msg = Message(message, encoding);\n  return {\n    address: key.address,\n    message: message,\n    sig: msg.sign(privateKey),\n    ts: Date.now(),\n  };\n};\n\nexport const encrypt = (message, key) => {\n  const privateKey = bitcore.PrivateKey.fromWIF(key.priv).toBuffer();\n  const data = enc(message, null, privateKey);\n  return {\n    address: key.address,\n    data,\n    ts: Date.now(),\n  };\n};\n\nexport const create = async (seed, account, o) => {\n  /********************************************************************\n   * The derivation path follows the\n   * BIP44 standard with a twist:\n   *\n   * - A new account is created per web host\n   * - It uses a new branch of \"2\" instead of (0 or 1)\n   *\n   * This way there is no overlap with existing BIP44 walletse but\n   * the wallet scheme can seamlessly integrate with them.\n   *\n   ********************************************************************/\n  const StarfishBranch = 2;\n  const path = `m/44'/0'/${account}'/${StarfishBranch}/0`;\n  const derived = seed.key.deriveChild(path);\n  const address = derived.privateKey.toAddress().toString();\n  const keys = {\n    path,\n    pub: derived.publicKey.toString(),\n    address,\n    host: o.host,\n  };\n\n  return keys;\n};\n\nexport const seed = (hex) => {\n  let buf = hex\n    ? Buffer.from(hex, \"hex\")\n    : bitcore.crypto.Random.getRandomBuffer(64);\n  try {\n    let key = bitcore.HDPrivateKey.fromSeed(buf);\n    return {\n      hex: buf.toString(\"hex\"),\n      key: key,\n    };\n  } catch (e) {\n    console.log(\"error\", e);\n    throw e;\n  }\n};\n\nexport const derive = (seed, path) => {\n  return seed.key.deriveChild(path);\n};\n\nexport const verify = (message, address, sig, encoding) => {\n  return Message(message, encoding).verify(address, sig);\n};\n","import bodyParser from \"body-parser\";\nimport timeout from \"connect-timeout\";\nimport cors from \"cors\";\nimport { randomUUID } from \"crypto\";\nimport express from \"express\";\nimport fs from \"fs\";\nimport Datastore from \"nedb\";\nimport path, { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport Key from \"./key.js\";\nimport Seed from \"./seed.js\";\nimport State from \"./state.js\";\nimport * as Wallet from \"./wallet/index.js\";\n\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst app = express();\nconst TIMEOUT = 20;\nconst defaultPort = 21000;\nconst defaultExpireTime = \"once\";\n\nconst allowedOrigins = [\n  `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n    process.env.TOKENPASS_PORT || \"21000\"\n  }`,\n];\nconst whitelist = process.env.TOKENPASS_ORIGIN_WHITELIST;\nif (whitelist) {\n  allowedOrigins.push(...whitelist.split(\",\"));\n}\n\nconst hostFromOrigin = (headers) => {\n  return headers.origin ? new URL(headers.origin).host : null; // \"localhost\";\n};\n\nconst expireSelectionToTime = (expireSelection) => {\n  switch (expireSelection) {\n    case \"forever\":\n      return 0;\n    case \"once\":\n      return 10000;\n    case \"1h\":\n      return 3600000;\n    case \"1d\":\n      return 86400000;\n    case \"1w\":\n      return 604800000;\n    case \"1m\":\n      return 2592000000;\n    default:\n      return defaultExpireTime;\n  }\n};\n\nconst init = (config) => {\n  const dbpath = config.db;\n  if (!fs.existsSync(dbpath)) fs.mkdirSync(dbpath, { recursive: true });\n  const seed = new Seed({ db: dbpath, wallet: Wallet, Datastore: Datastore });\n  const K = new Key({ db: dbpath, wallet: Wallet, Datastore: Datastore });\n  const S = new State({ db: dbpath, Datastore: Datastore });\n  app.set(\"views\", path.join(__dirname, \"views\"));\n  app.set(\"view engine\", \"ejs\");\n  app.use(timeout(\"\" + TIMEOUT + \"s\"));\n  app.use(bodyParser.json({ limit: \"50mb\" }));\n  app.use(bodyParser.raw({ type: \"application/octet-stream\", limit: \"50mb\" }));\n  app.use(bodyParser.urlencoded({ limit: \"50mb\", extended: true }));\n  app.use(express.static(path.join(__dirname, \"public\")));\n  app.options(\"*\", cors());\n  app.use(express.urlencoded({ extended: false }));\n\n  // Sign a message\n  app.post(\"/sign\", cors(), async (req, res) => {\n    // when a tokenpass wallet connects the referrer is empty\n    console.log(\"SIGN ATTEMPTED FROM\", req.headers.origin, {\n      message: req.body.message,\n      authToken: req.headers.authorization,\n    });\n    let message = req.body.message;\n    let encoding = req.body.encoding || \"utf8\";\n\n    if (K.getSeed()) {\n      // Check for an access token\n      const accessToken = req.headers.authorization;\n      if ((accessToken === undefined) | (accessToken === null)) {\n        res.status(401).json({\n          error: \"Please provide an access token in the Authorization header.\",\n          code: 2,\n          success: false,\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n        });\n        return;\n      }\n\n      // Check that the access token is valid\n      const state = await S.findOne({ accessToken });\n\n      if (!state?.accessToken || state.accessToken !== accessToken) {\n        res.status(401).json({\n          error: \"Invalid access token.\",\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n          code: 3,\n          success: false,\n        });\n        return;\n      }\n\n      let host = accessToken ? state.host : hostFromOrigin(req.headers);\n      // use host associated with the access token if provided\n      if (!host) {\n        // no host means its youself on localhost\n        host = process.env.TOKENPASS_HOST || \"localhost\";\n        console.log(\"no origin, using\", host);\n      }\n\n      const expired = state.expireTime && state.expireTime < Date.now();\n\n      console.log(\"SIGN:\", {\n        expireTime: state.expireTime,\n        now: Date.now(),\n        host,\n      });\n\n      // Check that the access token is not expired\n      if (expired) {\n        res.status(401).json({\n          error: \"Access token has expired.\",\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n          code: 5,\n        });\n        return;\n      }\n\n      let key = await K.findOrCreate({ host: host });\n      if (key) {\n        let signedResponse = await K.sign({\n          message: message,\n          key: key,\n          encoding: encoding,\n          ts: Date.now(),\n        });\n\n        // Rotate the access token\n        // const newAccessToken = randomUUID();\n        // await S.update({\n        //   host,\n        //   accessToken: newAccessToken,\n        // });\n\n        // signedResponse.accessToken = newAccessToken;\n\n        res.status(200).json(signedResponse);\n        return;\n      } else {\n        res\n          .status(417)\n          .json({ error: \"please create a wallet.\", success: false });\n        return;\n      }\n    } else {\n      res.status(401).json({\n        errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n          process.env.TOKENPASS_PORT || \"21000\"\n        }/auth`,\n        error: \"Check that TokenPass is running and you're signed in.\",\n        code: 1,\n      });\n    }\n  });\n\n  app.post(\"/encrypt\", cors(), async (req, res) => {\n    let message = req.body.message;\n\n    if (K.getSeed()) {\n      // Check for an access token\n      const accessToken = req.headers.authorization;\n      if ((accessToken === undefined) | (accessToken === null)) {\n        res.status(401).json({\n          error: \"Please provide an access token in the Authorization header.\",\n          code: 2,\n          success: false,\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n        });\n        return;\n      }\n\n      const host = hostFromOrigin(req.headers);\n\n      // TODO:Check that the access token is valid\n      const state = await S.findOne({ accessToken });\n      if (!state) {\n        res.status(401).json({\n          error: \"Invalid access token.\",\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n          code: 3,\n          success: false,\n        });\n        return;\n      }\n\n      const key = await K.findOrCreate({ host: state.host });\n      if (!key) {\n        res.status(417).json({ error: \"please create a wallet.\" });\n        return;\n      }\n\n      const { address, data, sig, ts } = K.encrypt({ message, key });\n      console.log({ address, data, sig, ts });\n      res.status(200).json({ data, address, sig, ts });\n    } else {\n      res.status(401).json({\n        errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n          process.env.TOKENPASS_PORT || \"21000\"\n        }/auth`,\n        error: \"Check that TokenPass is running and you're signed in.\",\n        code: 1,\n      });\n    }\n  });\n\n  // First time seed creation\n  app.post(\"/register\", async (req, res) => {\n    let s = await seed.create(req.body.password);\n    K.setSeed(s);\n\n    // create first state for localhost with an icon\n    const state = await S.findOrCreate({\n      host: process.env.TOKENPASS_HOST || \"localhost\",\n    });\n    if (!state.icon) {\n      state.icon = \"/auth/icon\";\n      await S.update(state);\n    }\n\n    res.json({});\n  });\n\n  // Import seed\n  app.post(\"/import\", async (req, res) => {\n    try {\n      let s = await seed.importKey(req.body.hex, req.body.password);\n      K.setSeed(s);\n      res.json({});\n    } catch (e) {\n      res.json({ error: \"invalid seed\", success: false });\n    }\n  });\n\n  // Export seed\n  app.post(\"/export\", async (req, res) => {\n    try {\n      let hex = await seed.exportKey(req.body.password);\n      if (hex) {\n        res.json({ seed: hex });\n      } else {\n        res.status(401).json({\n          error: \"invalid\",\n          success: false,\n          errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n            process.env.TOKENPASS_PORT || \"21000\"\n          }/auth`,\n        });\n      }\n    } catch (e) {}\n  });\n\n  // Update state object\n  app.post(\"/state\", cors(), async (req, res) => {\n    let referer = req.headers.origin;\n    let host = new URL(referer).host;\n\n    const s = await S.findOne({ host });\n    if (s) {\n      if (req.query.mode === \"clear\") {\n        await S.delete({ host });\n        await S.update({ ...req.body, host });\n      } else {\n        S.update({ ...req.body, host });\n      }\n    } else {\n      S.insert({ ...req.body, host });\n    }\n\n    res.json({ success: true });\n  });\n\n  // Update profile object\n  app.post(\"/profile\", cors(), async (req, res) => {\n    if (K.getSeed()) {\n      let host = \"global\";\n      try {\n        const s = await S.findOne({ host });\n        let finalState = { ...req.body, host };\n        if (s) {\n          if (req.query.mode === \"clear\") {\n            await S.delete({ host });\n          }\n          S.update(finalState);\n        } else {\n          S.insert(finalState);\n        }\n        res.json({ success: true });\n      } catch (error) {\n        console.error(error);\n        res.status(500).json({ success: false, error: error.toString() });\n      }\n    } else {\n      res.status(401).json({\n        error:\n          \"please check that TokenPass is running and you're signed in. check TokenPass dashboard at http://localhost:21000\",\n        code: 1,\n        errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n          process.env.TOKENPASS_PORT || \"21000\"\n        }`,\n      });\n    }\n  });\n\n  // Update state object\n  app.delete(\"/state\", cors(), async (req, res) => {\n    let referer = req.headers.origin;\n    let host = new URL(referer).host;\n\n    S.delete({ ...req.body, host });\n\n    res.json({ success: true });\n  });\n\n  // Get the global profile\n  app.get(\"/profile\", cors(), async (req, res) => {\n    let state = await S.findOne({ host: \"global\" });\n    res.json(state);\n  });\n\n  // Get the state object\n  app.get(\"/state\", cors(), async (req, res) => {\n    let referer = req.headers.origin;\n    let host = new URL(referer).host;\n\n    let state = await S.findOne({ host });\n\n    res.json(state);\n  });\n\n  // Decrypt wallet with password at startup\n  app.post(\"/login\", async (req, res) => {\n    try {\n      let s = await seed.get(req.body.password);\n      if (s) {\n        K.setSeed(s);\n\n        // We do not give an access token here.\n        // Those are per hose, this is global\n        res.json({ success: true });\n      } else {\n        res.json({ error: \"invalid\", success: false });\n      }\n    } catch (e) {}\n  });\n\n  // Clear seed so the server stops signing requests\n  app.post(\"/logout\", cors(), (req, res) => {\n    K.setSeed(null);\n    res.json({ success: true });\n  });\n\n  // Ask a connected wallet to fund a raw tx\n  app.post(\"/fund\", cors(), async (req, res) => {\n    const key = K.getSeed();\n    if (key) {\n      const url = `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n        process.env.TOKENPASS_PORT || \"21000\"\n      }/fund`;\n      let referer = req.headers.origin;\n      let host = referer ? new URL(referer).host : \"localhost\";\n\n      // make sure we have permission to fund for this host\n      const state = await S.findOne({ host });\n      if (!state.scopes?.includes(\"fund\")) {\n        res.status(403).json({\n          error: \"Insufficient permission\",\n          code: 7,\n        });\n        return;\n      }\n\n      const authToken = state.accessToken;\n      let rawtx = req.body.rawtx;\n      try {\n        const response = await fetch(url, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            rawtx,\n            broadcast: true,\n            sigma: true,\n            host,\n            authToken,\n          }),\n        });\n\n        const json = await response.json();\n        res.json(json);\n      } catch (e) {\n        console.error(e);\n        res.status(500).json({ success: false, error: e.toString() });\n      }\n    } else {\n      res.status(401).json({\n        error:\n          \"please check that TokenPass is running and you're signed in. check TokenPass dashboard at http://localhost:21000\",\n        code: 1,\n        errorURL: `http://${process.env.TOKENPASS_HOST || \"localhost\"}:${\n          process.env.TOKENPASS_PORT || \"21000\"\n        }/auth`,\n      });\n    }\n  });\n\n  // Decrypt wallet with password at startup\n  app.post(\"/login\", async (req, res) => {\n    try {\n      let s = await seed.get(req.body.password);\n      if (s) {\n        K.setSeed(s);\n        res.json({ success: true });\n      } else {\n        res.json({ error: \"invalid\", success: false });\n      }\n    } catch (e) {}\n  });\n\n  // alias to vivi.railway.internal\n  // Create an auth token for some amount of time\n  app.post(\"/auth\", cors(), async (req, res) => {\n    console.log(\"AUTH ATTEMPTED FROM\", req.headers.origin, { host: req.body.host });\n    const pw = req.body.password;\n    try {\n      let s = await seed.get(pw);\n      if (s) {\n        K.setSeed(s);\n\n        // ! Forbid auth from any not allowed origin\n        // undefined is same network\n        if (\n          req.headers.origin &&\n          !allowedOrigins.includes(req.headers.origin)\n        ) {\n          res.status(403).json({\n            error: \"The origin is not authorized\",\n            code: 6,\n          });\n          return;\n        }\n\n        // Auth gets the host from the request body\n        const host = req.body.host;\n        console.log({ hosts: host, origin: req.headers.origin });\n\n        const expireSelection = req.body.expire;\n        const expireTime = expireSelectionToTime(expireSelection);\n\n        const accessToken = randomUUID();\n        const scopes = req.body.scopes?.split(\",\") || [];\n        const newState = {\n          host,\n          accessToken,\n          scopes,\n          icon: req.body.icon,\n          expireTime: Date.now() + expireTime,\n        };\n        await S.update(newState);\n        res.json({ success: true, accessToken, expireTime, host });\n      } else {\n        res.json({ error: \"invalid\", success: false });\n      }\n    } catch (e) {\n      res.status(500).json({ success: false, error: e.toString() });\n    }\n  });\n\n  // Ask wallet to prove ownership of a txid\n  app.get(\"/prove\", async (req, res) => {\n    let referer = req.headers.origin;\n    let host = new URL(referer).host;\n    let txid = req.query.txid;\n    let challengeStr = req.query.message;\n\n    // TODO: Find this txid in utxo store\n    let key = await Wallet.keyForTx(txid);\n    if (!key) {\n      res.status(404).json({\n        error: \"txid not found\",\n        code: 4,\n      });\n      return;\n    }\n    const { address, message, sig, ts } = Wallet.sign(challengeStr, key);\n    return res.json({ message, key, address, sig, ts });\n  });\n\n  // OAuth style login page for apps\n  app.get(\"/auth\", async (req, res) => {\n    const returnHost = new URL(req.query.returnURL).host;\n\n    // if host is undefined its localhost\n    const originHost = hostFromOrigin(req.headers);\n    const host = originHost || process.env.TOKENPASS_HOST || \"localhost\";\n\n    if (originHost && host !== returnHost) {\n      res.status(403).json({\n        error: \"The origin is not authorized \" + host + \" \" + returnHost,\n        code: 6,\n      });\n      return;\n    }\n\n    const returnURL = req.query.returnURL;\n    const icon = req.query.icon;\n    const scopes = req.query.scopes?.split(\",\") || [];\n\n    console.log(\"AUTH GET:\", {\n      returnURL,\n      icon,\n    });\n    res.render(\"auth\", {\n      returnURL,\n      icon,\n      scopes,\n      host: host || \"lostlhost\",\n    });\n  });\n\n  // Icon intended to be rendered in the auth page only\n  app.get(\"/auth/icon\", cors(), async (req, res) => {\n    // ! Forbid auth from any outside host\n    if (\n      req.headers.host !==\n      `${process.env.TOKENPASS_HOST || \"localhost\"}:${\n        process.env.TOKENPASS_PORT || \"21000\"\n      }`\n    ) {\n      res.status(403).json({\n        error: \"The origin is not authorized\" + req.headers.origin,\n        code: 6,\n      });\n      return;\n    }\n\n    // workaround to import not working in esm\n    const minidenticon = async (str) => {\n      const module = await import(\"minidenticons\");\n      return module.minidenticon(str);\n    };     \n\n    res.set(\"Content-Type\", \"image/svg+xml\");\n    res.set(\"Cache-Control\", \"max-age=31536000\");\n\n    // derive a icon from localhost key\n    if (K.getSeed()) {\n      let k = await K.findOrCreate({\n        host: \"localhost\",\n      });\n      res.send(await minidenticon(k.pub));\n    } else {\n      // default icon\n      res.send(await minidenticon(\"Anon\"));\n    }\n  });\n\n  // Dashboard web page\n  app.get(\"/\", async (req, res) => {\n    if (K.getSeed()) {\n      // if host is specified\n      let keys = (await K.all()) || [];\n      let states = (await S.all()) || [];\n      res.render(\"home\", { keys, states, seed: true });\n    } else {\n      let seedCount = await seed.count();\n      if (seedCount) {\n        const host = hostFromOrigin(req.headers);\n        res.render(\"login\", { host });\n      } else {\n        res.render(\"home\", { seed: false });\n      }\n    }\n  });\n\n  app.listen(process.env.TOKENPASS_PORT || defaultPort, () => {\n    console.log(\n      `TokenPass listening at http://${\n        process.env.TOKENPASS_HOST || \"localhost\"\n      }:${process.env.TOKENPASS_PORT || \"21000\"}`\n    );\n  });\n};\nexport { init };\n"],"names":["Key","constructor","config","this","db","Datastore","filename","autoload","wallet","setSeed","s","seed","getSeed","sign","o","message","key","encoding","encrypt","findOrCreate","findOne","count","console","log","create","insert","Promise","resolve","reject","err","transform","find","keys","map","k","doc","derived","derive","path","priv","privateKey","toString","pub","publicKey","address","toAddress","all","text","keystr","keyBuffer","iv","crypto","randomBytes","createHash","update","digest","cipher","createCipheriv","encrypted","Buffer","concat","final","encryptedData","Seed","get","password","r","decrypted","from","encryptedText","decipher","createDecipheriv","decrypt","hex","e","importKey","res","exportKey","State","setState","state","getState","host","_id","states","delete","remove","$set","upsert","returnUpdatedDocs","numReplaced","accessToken","_","bitcore","deps","PrivateKey","PublicKey","Address","BufferWriter","ECDSA","Signature","sha256sha256","Hash","JSUtil","util","js","$","preconditions","Message","checkArgument","isString","includes","MAGIC_BYTES","prototype","magicHash","prefix1","varintBufNum","length","messageBuffer","prefix2","buf","_sign","hash","ecdsa","hashbuf","privkey","pubkey","toPublicKey","signRandomK","calci","sig","wif","toWIF","fromWIF","toCompact","_verify","signature","verified","verify","error","bitcoinAddress","signatureString","fromString","fromCompact","signatureAddress","fromPublicKey","network","str","fromJSON","json","isValidJSON","JSON","parse","toObject","toJSON","stringify","inspect","global","_bitcore","msg","ts","Date","now","data","enc","toBuffer","async","account","deriveChild","Random","getRandomBuffer","HDPrivateKey","fromSeed","__dirname","dirname","fileURLToPath","url","app","express","allowedOrigins","process","env","TOKENPASS_HOST","TOKENPASS_PORT","whitelist","TOKENPASS_ORIGIN_WHITELIST","push","split","hostFromOrigin","headers","origin","URL","init","dbpath","fs","existsSync","mkdirSync","recursive","Wallet","K","S","set","join","use","timeout","bodyParser","limit","raw","type","urlencoded","extended","static","options","cors","post","req","body","authToken","authorization","undefined","status","code","success","errorURL","expired","expireTime","signedResponse","icon","query","mode","_extends","finalState","_state$scopes","referer","scopes","rawtx","response","fetch","method","broadcast","sigma","pw","_req$body$scopes","hosts","expireSelection","expireSelectionToTime","expire","randomUUID","newState","txid","challengeStr","_req$query$scopes","returnHost","returnURL","originHost","render","minidenticon","import","send","listen"],"mappings":"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"}