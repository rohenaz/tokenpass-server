import e from"body-parser";import t from"connect-timeout";import s from"cors";import o,{randomUUID as r}from"crypto";import n from"express";import i from"fs";import a from"nedb";import c,{dirname as d}from"path";import{fileURLToPath as u}from"url";import h from"bitcore-lib";function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var o in s)Object.prototype.hasOwnProperty.call(s,o)&&(e[o]=s[o])}return e},l.apply(this,arguments)}class p{constructor(e){this.db=new e.Datastore({filename:e.db+"/keys.db",autoload:!0}),this.wallet=e.wallet,this.config=e}setSeed(e){this.seed=e}getSeed(){return this.seed}sign(e){return this.wallet.sign(e.message,e.key,e.encoding)}encrypt(e){return this.wallet.encrypt(e.message,e.key)}async findOrCreate(e){let t=await this.findOne(e);if(!t){let s=await this.count({});if(!this.seed)return console.log("Please go to http://localhost:21000 and create a wallet"),null;t=await this.wallet.create(this.seed,s,e),t=await this.insert(t)}return t}findOne(e){return new Promise((t,s)=>{this.db.findOne(e,(e,s)=>{t(s?this.transform(s):null)})})}find(e){return new Promise((t,s)=>{this.db.find(e,(e,s)=>{t(s.map(e=>this.transform(e)))})})}count(e){return new Promise((t,s)=>{this.db.count(e,(e,s)=>{t(s)})})}insert(e){return new Promise((t,s)=>{this.db.insert(e,(s,o)=>{t(this.transform(e))})})}transform(e){let t=this.wallet.derive(this.seed,e.path);return e.priv=t.privateKey.toString(),e.pub=t.publicKey.toString(),e.address=t.publicKey.toAddress().toString(),e}all(){return new Promise((e,t)=>{this.db.find({},(t,s)=>{e(s.map(e=>this.transform(e)))})})}}function g(e,t,s){const r=o.randomBytes(16);s||(s=o.createHash("sha256").update(t).digest());let n=o.createCipheriv("aes-256-cbc",s,r),i=n.update(e);return i=Buffer.concat([i,n.final()]),{iv:r.toString("hex"),encryptedData:i.toString("hex")}}class f{constructor(e){this.db=new e.Datastore({filename:e.db+"/seed.db",autoload:!0}),this.wallet=e.wallet}get(e){return new Promise((t,s)=>{this.db.findOne({},(s,r)=>{if(r)try{let s=function(e,t,s){const r=Buffer.from(e.iv,"hex");s||(s=o.createHash("sha256").update(t).digest());let n=Buffer.from(e.encryptedData,"hex"),i=o.createDecipheriv("aes-256-cbc",s,r),a=i.update(n);return a=Buffer.concat([a,i.final()]),a.toString()}(r.hex,e),n=this.wallet.seed(s);t(n)}catch(e){t(null)}else t(null)})})}importKey(e,t){return new Promise((s,o)=>{try{let o=this.wallet.seed(e);this.db.insert({hex:g(o.hex,t)},(e,t)=>{s(o)})}catch(e){o(e)}})}async exportKey(e){return(await this.get(e)).hex}count(){return new Promise((e,t)=>{this.db.count({},(t,s)=>{e(s)})})}create(e){return new Promise((t,s)=>{let o=this.wallet.seed();this.db.insert({hex:g(o.hex,e)},(e,s)=>{t(o)})})}}class S{constructor(e){this.db=new e.Datastore({filename:e.db+"/state.db",autoload:!0})}setState(e){this.state=e}getState(){return this.state}async findOrCreate(e){let t=await this.findOne({host:e.host});return t||(t=await this.insert(e)),t}findOne(e){return new Promise((t,s)=>{this.db.findOne(e,(e,s)=>{s?(delete s._id,t(s)):t(null)})})}find(e){return new Promise((t,s)=>{this.db.find(e,(e,s)=>{t(s)})})}delete(e){return new Promise((t,s)=>{this.db.remove(e,(e,s)=>{t(s)})})}count(e){return new Promise((t,s)=>{this.db.count(e,(e,s)=>{t(s)})})}insert(e){return new Promise((t,s)=>{this.db.insert(e,(s,o)=>{this.setState(e),t(e)})})}update(e){return new Promise((t,s)=>{this.db.update({host:e.host},{$set:e},{upsert:!0,returnUpdatedDocs:!0},(e,s,o)=>{console.log("UPDATED",{err:e,accessToken:o.accessToken}),this.setState(o),t(o)})})}all(){return new Promise((e,t)=>{this.db.find({},(t,s)=>{e(s)})})}}var m=h.deps._,y=h.PrivateKey,w=h.PublicKey,T=h.Address,v=h.encoding.BufferWriter,O=h.crypto.ECDSA,b=h.crypto.Signature,P=h.crypto.Hash.sha256sha256,A=h.util.js,K=h.util.preconditions,j=function e(t,s="utf8"){return this instanceof e?(K.checkArgument(m.isString(t),"First argument should be a string. You can specify the encoding as the second parameter"),K.checkArgument(["ascii","utf8","utf16le","ucs2","base64","latin1","binary","hex"].includes(s),"Second argument should be a valid BufferEncoding: 'utf8', 'hex', or 'base64', etc"),this.message=t,this.encoding=s,this):new e(t,s)};j.MAGIC_BYTES=Buffer.from("Bitcoin Signed Message:\n"),j.prototype.magicHash=function(){var e=v.varintBufNum(j.MAGIC_BYTES.length),t=Buffer.from(this.message,this.encoding),s=v.varintBufNum(t.length),o=Buffer.concat([e,j.MAGIC_BYTES,s,t]);return P(o)},j.prototype._sign=function(e){K.checkArgument(e instanceof y,"First argument should be an instance of PrivateKey");var t=this.magicHash(),s=new O;return s.hashbuf=t,s.privkey=e,s.pubkey=e.toPublicKey(),s.signRandomK(),s.calci(),s.sig},j.prototype.sign=function(e){let t=e.toWIF();return e=y.fromWIF(t),this._sign(e).toCompact().toString("base64")},j.prototype._verify=function(e,t){K.checkArgument(e instanceof w,"First argument should be an instance of PublicKey"),K.checkArgument(t instanceof b,"Second argument should be an instance of Signature");var s=this.magicHash(),o=O.verify(s,t,e);return o||(this.error="The signature was invalid"),o},j.prototype.verify=function(e,t){K.checkArgument(e),K.checkArgument(t&&m.isString(t)),m.isString(e)&&(e=T.fromString(e));var s=b.fromCompact(Buffer.from(t,"base64")),o=new O;o.hashbuf=this.magicHash(),o.sig=s;var r=o.toPublicKey(),n=T.fromPublicKey(r,e.network);return e.toString()!==n.toString()?(this.error="The signature did not match the message digest",!1):this._verify(r,s)},j.fromString=function(e){return new j(e)},j.fromJSON=function(e){return A.isValidJSON(e)&&(e=JSON.parse(e)),new j(e.message)},j.prototype.toObject=function(){return{message:this.message,encoding:this.encoding}},j.prototype.toJSON=function(){return JSON.stringify(this.toObject())},j.prototype.toString=function(){return this.message},j.prototype.inspect=function(){return"<Message: "+this.toString()+">"},delete global._bitcore;const k=(e,t,s)=>{const o=h.PrivateKey.fromWIF(t.priv),r=j(e,s);return{address:t.address,message:e,sig:r.sign(o),ts:Date.now()}};var _={__proto__:null,sign:k,encrypt:(e,t)=>{const s=g(e,null,h.PrivateKey.fromWIF(t.priv).toBuffer());return{address:t.address,data:s,ts:Date.now()}},create:async(e,t,s)=>{const o=`m/44'/0'/${t}'/2/0`,r=e.key.deriveChild(o),n=r.privateKey.toAddress().toString();return{path:o,pub:r.publicKey.toString(),address:n,host:s.host}},seed:e=>{let t=e?Buffer.from(e,"hex"):h.crypto.Random.getRandomBuffer(64);try{let e=h.HDPrivateKey.fromSeed(t);return{hex:t.toString("hex"),key:e}}catch(e){throw console.log("error",e),e}},derive:(e,t)=>e.key.deriveChild(t),verify:(e,t,s,o)=>j(e,o).verify(t,s)};const E=d(u(import.meta.url)),N=n(),R=[`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}`],x=process.env.TOKENPASS_ORIGIN_WHITELIST;x&&R.push(...x.split(","));const $=e=>e.origin?new URL(e.origin).host:null,H=o=>{const d=o.db;i.existsSync(d)||i.mkdirSync(d,{recursive:!0});const u=new f({db:d,wallet:_,Datastore:a}),h=new p({db:d,wallet:_,Datastore:a}),g=new S({db:d,Datastore:a});N.set("views",c.join(E,"views")),N.set("view engine","ejs"),N.use(t("20s")),N.use(e.json({limit:"50mb"})),N.use(e.raw({type:"application/octet-stream",limit:"50mb"})),N.use(e.urlencoded({limit:"50mb",extended:!0})),N.use(n.static(c.join(E,"public"))),N.options("*",s()),N.use(n.urlencoded({extended:!1})),N.post("/sign",s(),async(e,t)=>{console.log("SIGN ATTEMPTED FROM",e.headers.origin,{message:e.body.message,authToken:e.headers.authorization});let s=e.body.message,o=e.body.encoding||"utf8";if(h.getSeed()){const r=e.headers.authorization;if(void 0===r|null===r)return void t.status(401).json({error:"Please provide an access token in the Authorization header.",code:2,success:!1,errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`});const n=await g.findOne({accessToken:r});if(null==n||!n.accessToken||n.accessToken!==r)return void t.status(401).json({error:"Invalid access token.",errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`,code:3,success:!1});let i=r?n.host:$(e.headers);i||(i=process.env.TOKENPASS_HOST||"localhost",console.log("no origin, using",i));const a=n.expireTime&&n.expireTime<Date.now();if(console.log("SIGN:",{expireTime:n.expireTime,now:Date.now(),host:i}),a)return void t.status(401).json({error:"Access token has expired.",errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`,code:5});let c=await h.findOrCreate({host:i});if(c){let e=await h.sign({message:s,key:c,encoding:o,ts:Date.now()});return void t.status(200).json(e)}t.status(417).json({error:"please create a wallet.",success:!1})}else t.status(401).json({errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`,error:"Check that TokenPass is running and you're signed in.",code:1})}),N.post("/encrypt",s(),async(e,t)=>{let s=e.body.message;if(h.getSeed()){const o=e.headers.authorization;if(void 0===o|null===o)return void t.status(401).json({error:"Please provide an access token in the Authorization header.",code:2,success:!1,errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`});$(e.headers);const r=await g.findOne({accessToken:o});if(!r)return void t.status(401).json({error:"Invalid access token.",errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`,code:3,success:!1});const n=await h.findOrCreate({host:r.host});if(!n)return void t.status(417).json({error:"please create a wallet."});const{address:i,data:a,sig:c,ts:d}=h.encrypt({message:s,key:n});console.log({address:i,data:a,sig:c,ts:d}),t.status(200).json({data:a,address:i,sig:c,ts:d})}else t.status(401).json({errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`,error:"Check that TokenPass is running and you're signed in.",code:1})}),N.post("/register",async(e,t)=>{let s=await u.create(e.body.password);h.setSeed(s);const o=await g.findOrCreate({host:process.env.TOKENPASS_HOST||"localhost"});o.icon||(o.icon="/auth/icon",await g.update(o)),t.json({})}),N.post("/import",async(e,t)=>{try{let s=await u.importKey(e.body.hex,e.body.password);h.setSeed(s),t.json({})}catch(e){t.json({error:"invalid seed",success:!1})}}),N.post("/export",async(e,t)=>{try{let s=await u.exportKey(e.body.password);s?t.json({seed:s}):t.status(401).json({error:"invalid",success:!1,errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`})}catch(e){}}),N.post("/state",s(),async(e,t)=>{let s=new URL(e.headers.origin).host;await g.findOne({host:s})?"clear"===e.query.mode?(await g.delete({host:s}),await g.update(l({},e.body,{host:s}))):g.update(l({},e.body,{host:s})):g.insert(l({},e.body,{host:s})),t.json({success:!0})}),N.post("/profile",s(),async(e,t)=>{if(h.getSeed()){let s="global";try{const o=await g.findOne({host:s});let r=l({},e.body,{host:s});o?("clear"===e.query.mode&&await g.delete({host:s}),g.update(r)):g.insert(r),t.json({success:!0})}catch(e){console.error(e),t.status(500).json({success:!1,error:e.toString()})}}else t.status(401).json({error:"please check that TokenPass is running and you're signed in. check TokenPass dashboard at http://localhost:21000",code:1,errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}`})}),N.delete("/state",s(),async(e,t)=>{let s=new URL(e.headers.origin).host;g.delete(l({},e.body,{host:s})),t.json({success:!0})}),N.get("/profile",s(),async(e,t)=>{let s=await g.findOne({host:"global"});t.json(s)}),N.get("/state",s(),async(e,t)=>{let s=new URL(e.headers.origin).host,o=await g.findOne({host:s});t.json(o)}),N.post("/login",async(e,t)=>{try{let s=await u.get(e.body.password);s?(h.setSeed(s),t.json({success:!0})):t.json({error:"invalid",success:!1})}catch(e){}}),N.post("/logout",s(),(e,t)=>{h.setSeed(null),t.json({success:!0})}),N.post("/fund",s(),async(e,t)=>{if(h.getSeed()){var s;const o=`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/fund`;let r=e.headers.origin,n=r?new URL(r).host:"localhost";const i=await g.findOne({host:n});if(null==(s=i.scopes)||!s.includes("fund"))return void t.status(403).json({error:"Insufficient permission",code:7});const a=i.accessToken;let c=e.body.rawtx;try{const e=await fetch(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({rawtx:c,broadcast:!0,sigma:!0,host:n,authToken:a})}),s=await e.json();t.json(s)}catch(e){console.error(e),t.status(500).json({success:!1,error:e.toString()})}}else t.status(401).json({error:"please check that TokenPass is running and you're signed in. check TokenPass dashboard at http://localhost:21000",code:1,errorURL:`http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}/auth`})}),N.post("/login",async(e,t)=>{try{let s=await u.get(e.body.password);s?(h.setSeed(s),t.json({success:!0})):t.json({error:"invalid",success:!1})}catch(e){}}),N.post("/auth",s(),async(e,t)=>{console.log("AUTH ATTEMPTED FROM",e.headers.origin,{host:e.body.host});const s=e.body.password;try{let n=await u.get(s);if(n){var o;if(h.setSeed(n),e.headers.origin&&!R.includes(e.headers.origin))return void t.status(403).json({error:"The origin is not authorized",code:6});const s=e.body.host;console.log({hosts:s,origin:e.headers.origin});const i=(e=>{switch(e){case"forever":return 0;case"once":return 1e4;case"1h":return 36e5;case"1d":return 864e5;case"1w":return 6048e5;case"1m":return 2592e6;default:return"once"}})(e.body.expire),a=r(),c={host:s,accessToken:a,scopes:(null==(o=e.body.scopes)?void 0:o.split(","))||[],icon:e.body.icon,expireTime:Date.now()+i};await g.update(c),t.json({success:!0,accessToken:a,expireTime:i,host:s})}else t.json({error:"invalid",success:!1})}catch(e){t.status(500).json({success:!1,error:e.toString()})}}),N.get("/prove",async(e,t)=>{new URL(e.headers.origin);let s=e.query.txid,o=e.query.message,r=await(void 0)(s);if(!r)return void t.status(404).json({error:"txid not found",code:4});const{address:n,message:i,sig:a,ts:c}=k(o,r);return t.json({message:i,key:r,address:n,sig:a,ts:c})}),N.get("/auth",async(e,t)=>{var s;const o=new URL(e.query.returnURL).host,r=$(e.headers),n=r||process.env.TOKENPASS_HOST||"localhost";if(r&&n!==o)return void t.status(403).json({error:"The origin is not authorized "+n+" "+o,code:6});const i=e.query.returnURL,a=e.query.icon,c=(null==(s=e.query.scopes)?void 0:s.split(","))||[];console.log("AUTH GET:",{returnURL:i,icon:a}),t.render("auth",{returnURL:i,icon:a,scopes:c,host:n||"lostlhost"})}),N.get("/auth/icon",s(),async(e,t)=>{if(e.headers.host!==`${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}`)return void t.status(403).json({error:"The origin is not authorized"+e.headers.origin,code:6});const s=async e=>(await import("minidenticons")).minidenticon(e);if(t.set("Content-Type","image/svg+xml"),t.set("Cache-Control","max-age=31536000"),h.getSeed()){let e=await h.findOrCreate({host:"localhost"});t.send(await s(e.pub))}else t.send(await s("Anon"))}),N.get("/",async(e,t)=>{if(h.getSeed()){let e=await h.all()||[],s=await g.all()||[];t.render("home",{keys:e,states:s,seed:!0})}else if(await u.count()){const s=$(e.headers);t.render("login",{host:s})}else t.render("home",{seed:!1})}),N.listen(process.env.TOKENPASS_PORT||21e3,()=>{console.log(`TokenPass listening at http://${process.env.TOKENPASS_HOST||"localhost"}:${process.env.TOKENPASS_PORT||"21000"}`)})};export{H as init};
//# sourceMappingURL=index.modern.js.map
